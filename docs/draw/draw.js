export default class Draw{constructor(){this.x=0,this.y=0,this.points=[],this.flag=!1}setup(a,b){if(b=b||{},'string'==typeof a||a.constructor===HTMLCanvasElement?b.canvas=a:b=a||b,this.fill=b.fill||null,this.line=b.line||'black',this.width=b.width||1,this.quality=b.quality||0.5,this.type=b.type||'image/webp',this.canvas='string'==typeof b.canvas?document.body.querySelector(b.canvas):b.canvas,!b.canvas)throw new Error('Signer - canvas option required');this.context=this.canvas.getContext('2d',{desynchronized:!0,preserveDrawingBuffer:!0}),this.canvas.style.cursor='crosshair',this.canvas.width=this.canvas.parentElement.clientWidth,this.canvas.height=this.canvas.parentElement.clientHeight,this.fill&&(this.context.fillStyle=this.fill,this.context.fillRect(0,0,this.canvas.width,this.canvas.height)),this.canvas.addEventListener('mouseup',this.tick.bind(this,this.change.bind(this,'up')),!1),this.canvas.addEventListener('mouseout',this.tick.bind(this,this.change.bind(this,'out')),!1),this.canvas.addEventListener('mousedown',this.tick.bind(this,this.change.bind(this,'down')),!1),this.canvas.addEventListener('mousemove',this.tick.bind(this,this.change.bind(this,'move')),!1),this.canvas.addEventListener('touchend',this.tick.bind(this,this.change.bind(this,'up')),!1),this.canvas.addEventListener('touchmove',this.tick.bind(this,this.change.bind(this,'move')),!1),this.canvas.addEventListener('touchstart',this.tick.bind(this,this.change.bind(this,'down')),!1)}tick(a,b){'resize'!==b.type&&b.cancelable&&b.preventDefault(),window.requestAnimationFrame(a.bind(this,b))}up(){this.flag=!1,this.points.length=0}out(){this.flag=!1,this.points.length=0}down(a,b){this.flag=!0,this.points.push({x:a,y:b})}move(a,b){if(this.flag){this.points.push({x:a,y:b}),this.context.beginPath(),this.context.moveTo(this.points[0].x,this.points[0].y);for(var c=1;c<this.points.length;c++)this.context.lineTo(this.points[c].x,this.points[c].y);this.context.strokeStyle=this.line,this.context.shadowColor=this.line,this.context.lineWidth=this.width,this.context.lineCap='round',this.context.lineJoin='round',this.context.shadowBlur=2,this.context.stroke(),this.context.closePath()}}change(a,b){const c=this.canvas.getBoundingClientRect(),d=b.touches?b.touches[0].clientX:b.clientX,e=b.touches?b.touches[0].clientY:b.clientY,f=d-c.left,g=e-c.top;this[a](f,g)}erase(){this.context.clearRect(0,0,this.canvas.width,this.canvas.height),this.fill&&(this.context.fillRect(0,0,this.canvas.width,this.canvas.height),this.context.fillStyle=this.fill)}async url(){const a=this;return new Promise(function(b){a.canvas.toBlob(function(a){const c=new FileReader;c.onload=function(){b(c.result)},c.readAsDataURL(a)},a.type,a.quality)})}async text(){const a=this;return new Promise(function(b){a.canvas.toBlob(function(a){const c=new FileReader;c.onload=function(){b(c.result)},c.readAsBinaryString(a)},a.type,a.quality)})}async buffer(){const a=this;return new Promise(function(b){a.canvas.toBlob(function(a){const c=new FileReader;c.onload=function(){b(c.result)},c.readAsArrayBuffer(a)},a.type,a.quality)})}async blob(){const a=this;return new Promise(function(b){a.canvas.toBlob(function(a){b(a)},a.type,a.quality)})}async image(a){const b=this;return new Promise(function(c){const d=new Image;d.src=URL.createObjectURL(a),d.onload=function(){b.context.drawImage(d,0,0),c()}})}}